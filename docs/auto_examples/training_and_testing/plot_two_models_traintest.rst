
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/training_and_testing/plot_two_models_traintest.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_training_and_testing_plot_two_models_traintest.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_training_and_testing_plot_two_models_traintest.py:


Regression: comparing two tabular models trained on simulated data
====================================================================

This script shows how to train two fusion models on a regression task with train/test protocol and multimodal tabular data.

Key Features:

- Importing models based on name.
- Training and testing models with train/test protocol.
- Saving trained models to a dictionary for later analysis.
- Plotting the results of a single model.
- Plotting the results of multiple models as a bar chart.
- Saving the results of multiple models as a csv file.

.. GENERATED FROM PYTHON SOURCE LINES 16-30

.. code-block:: default


    import importlib

    import matplotlib.pyplot as plt
    from tqdm.auto import tqdm

    from docs.examples import generate_sklearn_simulated_data
    from fusilli.data import get_data_module
    from fusilli.eval import Plotter
    from fusilli.fusion_models.base_model import BaseModel
    from fusilli.train import train_and_save_models
    from fusilli.utils.model_chooser import get_models




.. rst-class:: sphx-glr-script-out

.. code-block:: pytb

    Traceback (most recent call last):
      File "/Users/florencetownend/Library/CloudStorage/OneDrive-UniversityCollegeLondon/Projects/fusilli/docs/examples/training_and_testing/plot_two_models_traintest.py", line 24, in <module>
        from fusilli.eval import Plotter
    ImportError: cannot import name 'Plotter' from 'fusilli.eval' (/Users/florencetownend/Library/CloudStorage/OneDrive-UniversityCollegeLondon/Projects/fusilli/fusilli/eval.py)




.. GENERATED FROM PYTHON SOURCE LINES 31-42

1. Import fusion models
------------------------
Here we import the fusion models to be compared. The models are imported using the
:func:`~fusilli.utils.model_chooser.get_models` function, which takes a dictionary of conditions
as an input. The conditions are the attributes of the models, e.g. the class name, the modality type, etc.

The function returns a dataframe of the models that match the conditions. The dataframe contains the
method name, the class name, the modality type, the fusion type, the path to the model, and the path to the
model's parent class. The paths are used to import the models with the :func:`importlib.import_module`.

We're importing ConcatTabularData and TabularChannelWiseMultiAttention models for this example. Both are multimodal tabular models.

.. GENERATED FROM PYTHON SOURCE LINES 42-59

.. code-block:: default


    model_conditions = {
        "class_name": ["ConcatTabularData", "TabularChannelWiseMultiAttention"],
    }

    imported_models = get_models(model_conditions)
    print("Imported methods:")
    print(imported_models.method_name.values)

    fusion_models = []  # contains the class objects for each model
    for index, row in imported_models.iterrows():
        module = importlib.import_module(row["method_path"])
        module_class = getattr(module, row["class_name"])

        fusion_models.append(module_class)



.. GENERATED FROM PYTHON SOURCE LINES 60-72

2. Set the training parameters
--------------------------------
Here we define the parameters for training and testing the models. The parameters are stored in a dictionary and passed to most
of the methods in this library.
For training and testing, the necessary parameters are:

- ``test_size``: the proportion of the data to be used for testing.
- ``kfold_flag``: the user sets this to False for train/test protocol.
- ``log``: a boolean of whether to log the results using Weights and Biases.
- ``pred_type``: the type of prediction to be performed. This is either ``regression``, ``binary``, or ``classification``. For this example we're using regression.

If we were going to use a subspace-based fusion model, we would also need to set the latent dimensionality of the subspace with ``subspace_latdims``. This will be shown in a different example.

.. GENERATED FROM PYTHON SOURCE LINES 72-81

.. code-block:: default


    params = {
        "test_size": 0.2,
        "kfold_flag": False,
        "log": False,
        "pred_type": "regression",
    }



.. GENERATED FROM PYTHON SOURCE LINES 82-86

3. Generating simulated data
--------------------------------
Here we generate simulated data for the two tabular modalities for this example.
This function also simulated image data which we aren't using here.

.. GENERATED FROM PYTHON SOURCE LINES 86-95

.. code-block:: default


    params = generate_sklearn_simulated_data(
        num_samples=500,
        num_tab1_features=10,
        num_tab2_features=10,
        img_dims=(1, 100, 100),
        params=params,
    )


.. GENERATED FROM PYTHON SOURCE LINES 96-108

4. Training the first fusion model
----------------------------------
Here we train the first fusion model. We're using the ``train_and_save_models`` function to train and test the models.
This function takes the following inputs:

- ``trained_models_dict``: a dictionary to store the trained models.
- ``data_module``: the data module containing the data.
- ``params``: the parameters for training and testing.
- ``fusion_model``: the fusion model to be trained.
- ``init_model``: the initialised dummy fusion model.

First we'll create a dictionary to store both the trained models so we can compare them later.

.. GENERATED FROM PYTHON SOURCE LINES 108-110

.. code-block:: default

    all_trained_models = {}  # create dictionary to store trained models


.. GENERATED FROM PYTHON SOURCE LINES 111-120

To train the first model we need to:

1. *Choose the model*: We're using the first model in the ``fusion_models`` list we made earlier.
2. *Create a dictionary to store the trained model*: We're using the name of the model as the key. It may seem overkill to make a dictionary just to store one model, but we also use this when we do k-fold training to store the trained models from the different folds.
3. *Initialise the model with dummy data*: This is so we can find out whether there are extra instructions for creating the datamodule (such as a method for creating a graph datamodule).
4. *Print the attributes of the model*: To check it's been initialised correctly.
5. *Create the datamodule*: This is done with the :func:`~fusilli.data.get_data_module` function. This function takes the initialised model and the parameters as inputs. It returns the datamodule.
6. *Train and test the model*: This is done with the :func:`~fusilli.train.train_and_save_models` function. This function takes the trained_models_dict, the datamodule, the parameters, the fusion model, and the initialised model as inputs. It returns the trained_models_dict with the trained model added to it.
7. *Add the trained model to the ``all_trained_models`` dictionary*: This is so we can compare the results of the two models later.

.. GENERATED FROM PYTHON SOURCE LINES 120-142

.. code-block:: default


    fusion_model = fusion_models[0]

    print("Method name:", fusion_model.method_name)
    print("Modality type:", fusion_model.modality_type)
    print("Fusion type:", fusion_model.fusion_type)

    # Create the data module
    dm = get_data_module(fusion_model=fusion_model, params=params)

    # Train and test
    model_1_dict = train_and_save_models(
        data_module=dm,
        params=params,
        fusion_model=fusion_model,
        enable_checkpointing=False,  # False for the example notebooks
    )

    # Add trained model to dictionary
    all_trained_models[fusion_model.__name__] = model_1_dict[fusion_model.__name__]



.. GENERATED FROM PYTHON SOURCE LINES 143-147

5. Plotting the results of the first model
--------------------------------------------
We're using the :class:`~fusilli.eval.Plotter` class to plot the results of the first model. This class takes the dictionary of trained models and the parameters as inputs. It returns a dictionary of figures.
If there is one model in the dictionary (i.e. only one unique key), then it plots the figures for analysing the results of a single model.

.. GENERATED FROM PYTHON SOURCE LINES 147-152

.. code-block:: default


    plotter = Plotter(model_1_dict, params)
    single_model_figures_dict = plotter.plot_all()
    plotter.show_all(single_model_figures_dict)


.. GENERATED FROM PYTHON SOURCE LINES 153-156

6. Training the second fusion model
-------------------------------------
Here we train the second fusion model: TabularChannelWiseMultiAttention. We're using the same steps as before, but this time we're using the second model in the ``fusion_models`` list.

.. GENERATED FROM PYTHON SOURCE LINES 159-160

Choose the model

.. GENERATED FROM PYTHON SOURCE LINES 160-182

.. code-block:: default

    fusion_model = fusion_models[1]


    print("Method name:", fusion_model.method_name)
    print("Modality type:", fusion_model.modality_type)
    print("Fusion type:", fusion_model.fusion_type)

    # Create the data module
    dm = get_data_module(fusion_model=fusion_model, params=params)

    # Train and test
    model_2_dict = train_and_save_models(
        data_module=dm,
        params=params,
        fusion_model=fusion_model,
        enable_checkpointing=False,  # False for the example notebooks
    )

    # Add trained model to dictionary
    all_trained_models[fusion_model.__name__] = model_2_dict[fusion_model.__name__]



.. GENERATED FROM PYTHON SOURCE LINES 183-185

7. Plotting the results of the second model
----------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 185-190

.. code-block:: default


    plotter = Plotter(model_2_dict, params)
    single_model_figures_dict = plotter.plot_all()
    plotter.show_all(single_model_figures_dict)


.. GENERATED FROM PYTHON SOURCE LINES 191-194

8. Comparing the results of the two models
---------------------------------------------
Now we're going to compare the results of the two models. We're using the same steps as when we used Plotter before, but this time we're using the ``all_trained_models`` dictionary which contains both models.

.. GENERATED FROM PYTHON SOURCE LINES 194-199

.. code-block:: default


    comparison_plotter = Plotter(all_trained_models, params)
    comparison_plot_dict = comparison_plotter.plot_all()
    comparison_plotter.show_all(comparison_plot_dict)


.. GENERATED FROM PYTHON SOURCE LINES 200-203

9. Saving the metrics of the two models
-----------------------------------------
We can also get the metrics of the two models into a Pandas DataFrame using the :func:`~fusilli.eval.Plotter.get_performance_df` function.

.. GENERATED FROM PYTHON SOURCE LINES 203-205

.. code-block:: default

    performances_df = comparison_plotter.get_performance_df()
    performances_df


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.001 seconds)


.. _sphx_glr_download_auto_examples_training_and_testing_plot_two_models_traintest.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_two_models_traintest.py <plot_two_models_traintest.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_two_models_traintest.ipynb <plot_two_models_traintest.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
